/* -*- c-file-style: "stroustrup"; -*- */

%define semantic_tree_type Arith_Node

%{
#include <cstdio>
#include <cstdlib>
#include <string>

using namespace std;

#include "arith.h"

%}

/* Give names we can refer to in other files */
%token EXPO "**"

%debug
/* Declare interactive so that we can enter input from the terminal. */
%interactive

%%

// Programs and definitions

program : commandOrDefinition*;

commandOrDefinition : command
    | definition
    | syntaxDefinition
    | "(" "begin" commandOrDefinition+ ")";

definition : "(" "define" variable expression ")"
      | "(define" "(" variable defFormals ")" body ")"
      | "(" "begin" definition* ")";

defFormals : variable*
      | variable* "." variable;

syntaxDefinition :
	  "(" "define-syntax" keyword transformerSpec ")" ;


// Lexical structure

token : identifier | boolean | number
     | character | string
     | "(" | ")" | "#(" | "'" | "`" | "," | ",@" | ".";

delimiter : whitespace | "(" | ")" | "\"" | ";";

whitespace : " " | "\n"; //space-or-newline;

//-------------------------
comment : ";"; // <all subsequent characters up to a line break>;

atmosphere : whitespace | comment;

intertokenSpace : atmosphere*;

identifier : initial subsequent*
     | peculiarIdentifier;

initial : letter | specialInitial;

//-------------------------
letter : "a" | "b" | "c" | "..." | "z";

specialInitial : "!" | "$" | "%" | "&" | "*" | "/" | ":" | "<" | "="
     | ">" | "?" | "^" | "_" | "~";

subsequent : initial | digit
     | specialSubsequent;

digit : "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";

specialSubsequent : "+" | "-" | "." | "@";

peculiarIdentifier : "+" | "-" | "...";

syntacticKeyword : expressionKeyword
     | "else" | "=>" | "define" 
     | "unquote" | "unquote-splicing";

expressionKeyword : "quote" | "lambda" | "if"
     | "set!" | "begin" | "cond" | "and" | "or" | "case"
     | "let" | "let*" | "letrec" | "do" | "delay"
	 | "quasiquote";

variable : "any var not a key word" ; //<'any identifier that isn't also a syntactic-keyword>;

boolean : "#t" | "#f";

character : "#\\" anyCharacter
     | "#\\" characterName;

characterName : "space" | "newline";

string : "\"" stringElement* "\"";

stringElement : //<any-character-other-than-"-or-\>
     | "\\\"" | "\\\\" ;

number : num2| num8
	 | num10| num16;

//The following rules for num-R, complex-R, real-R, ureal-R, uinteger-R, and prefix-R should be replicated for R = 2, 8, 10, and 16. There are no rules for decimal-2, decimal-8, and decimal-16, which means that numbers containing decimal points or exponents must be in decimal radix.;

numR : prefixR complexR;

complexR : realR | realR "@" realR
    | realR "+" urealR "i" | realR "-" urealR "i"
    | realR "+" "i" | realR "-" "i"
    | "+" urealR "i" | "-" urealR "i" | "+" "i" | "-" "i";

realR : sign urealR;

urealR : uintegerR
    | uintegerR "/" uintegerR
	| decimalR;

decimal10 : uinteger10 suffix
    | "." digit10+ "#*" suffix
    | digit10+ "." digit10* "#*" suffix
    | digit10+ "#+" "." "#*" suffix;

uintegerR : digitR+ "#*";

prefixR : radixR exactness
    | exactness radixR;

suffix : "" 
    | exponentMarker sign digit10+;

exponentMarker : "e" | "s" | "f" | "d" | "l";

sign : ""  | "+" |  "-";

exactness : "" | "#i" | "#e";
radix2 : "#b";
radix8 : "#o";
radix10 : "" | "#d";
radix16 : "#x";
digit2 : "0" | "1";
digit8 : "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
digit10 : digit;
digit16 : digit10 | "a" | "b" | "c" | "d" | "e" | "f";

// External Representations

datum : simpleDatum | compoundDatum;

simpleDatum : boolean | number
     | character | string |  symbol;

symbol : identifier;

compoundDatum : list | vector;

list : '(' datum* ')' | '(' datum+ '.' datum ')'
       | abbreviation;

abbreviation : abbrevPrefix datum;

abbrevPrefix : "'" | "`" | "," | ",@";

vector : '#' '(' datum* ')';

//Expressions

expression : variable
     | literal
     | procedureCall
     | lambdaExpression
     | conditional
     | assignment
     | derivedExpression
     | macroUse
     | macroBlock;

literal : quotation | selfEvaluating;

selfEvaluating : boolean | number
     | character | string;

quotation : "'" datum | "(" "quote" datum ")";

procedureCall : "(" operator operand* ")";

operator : expression;

operand : expression;

lambdaExpression : "(" lambda formals body ")";

formals : "(" variable* ")" | variable
     | "(" variable+ "." variable ")";

body : definition* sequence;

sequence : command* expression;

command : expression;

conditional : "(" "if" test consequent alternate ")";

test : expression;

consequent : expression;

alternate : expression | empty;

assignment : "(" "set!" variable expression ")";

derivedExpression :
       "(" "cond" condClause+ ")"
     | "(" "cond" condClause* "(" "else" sequence ")" ")"
     | "(" "case" expression
         caseClause+ ")"
     | "(" "case" expression
         caseClause*
         "(" "else" sequence ")" ")"
     | "(" "and" test* ")"
     | "(" "or" test* ")"
     | "(" "let" "(" bindingSpec* ")" body ")"
     | "(" "let" variable "(" bindingSpec* ")" body ")"
     | "(" "let*" "(" bindingSpec* ")" body ")"
     | "(" "letrec" "(" bindingSpec* ")" body ")"
     | "(" "begin" sequence ")"
     | "(" "do" "(" iterationSpec* ")"
           "(" test doResult ")"
         command* ")"
     | "(" "delay" expression ")"
     | quasiquotation;

condClause : "(" test sequence ")"
      | "(" test ")"
      | "(" test "=>" recipient ")";

recipient : expression;

caseClause : "(" "(" datum* ")" sequence ")";

bindingSpec : "(" variable expression ")";

iterationSpec : "(" variable init step ")"
    | "(" variable init ")";

init : expression;

step : expression;

doResult : sequence | empty;

macroUse : "(" keyword datum* ")";

keyword : identifier;

macroBlock :
     "(" "let-syntax" "(" syntaxSpec* ")" body ")"
     | "(" "letrec-syntax" "(" syntaxSpec* ")" body ")";

syntaxSpec : "(" keyword transformerSpec ")";

%%

int
main (int argc, char* argv[])
{
    if (argc > 1) {
	FILE* inp = fopen (argv[1], "r");
	if (inp == NULL) {
	    fprintf (stderr, "could not open %s\n", argv[1]);
	    exit (1);
	}
	yypush_lexer (inp, argv[1]);
    } else
	yypush_lexer (stdin, "<stdin>");
    return yyparse ();
}
